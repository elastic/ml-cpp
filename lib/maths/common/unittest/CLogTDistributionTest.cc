/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the following additional limitation. Functionality enabled by the
 * files subject to the Elastic License 2.0 may only be used in production when
 * invoked by an Elasticsearch process with a license key installed that permits
 * use of machine learning features. You may not use this file except in
 * compliance with the Elastic License 2.0 and the foregoing additional
 * limitation.
 */

#include <core/CLogger.h>

#include <maths/common/CLogTDistribution.h>

#include <test/BoostTestCloseAbsolute.h>
#include <test/CRandomNumbers.h>

#include <boost/test/unit_test.hpp>

#include <cmath>

BOOST_AUTO_TEST_SUITE(CLogTDistributionTest)

using namespace ml;
using namespace maths;
using namespace common;
using namespace test;

using TDoubleVec = std::vector<double>;

BOOST_AUTO_TEST_CASE(testMode) {
    // The mode of the distribution should be at the maximum
    // of the distribution, i.e. p.d.f. derivative should be
    // zero and curvature should be positive.

    double eps = 1e-5;

    for (auto degreesFreedom : {2.0, 10.0, 40.0}) {
        for (auto location : {1.0, 2.0, 3.0, 4.0, 6.0}) {
            for (auto squareScale : {0.5, 1.0, 1.5, 2.0, 3.0}) {
                LOG_DEBUG(<< "degrees freedom = " << degreesFreedom << ", location = "
                          << location << ", scale = " << std::sqrt(squareScale));

                CLogTDistribution logt(degreesFreedom, location, std::sqrt(squareScale));

                double x = mode(logt);

                if (x != 0.0) {
                    double pMinusEps = pdf(logt, x - eps);
                    double p = pdf(logt, x);
                    double pPlusEps = pdf(logt, x + eps);

                    double derivative = (pPlusEps - pMinusEps) / 2.0 / eps;
                    double curvature = (pPlusEps - 2.0 * p + pMinusEps) / eps / eps;

                    // Gradient zero + curvature negative => maximum.
                    BOOST_REQUIRE_CLOSE_ABSOLUTE(0.0, derivative, 1e-6);
                    BOOST_TEST_REQUIRE(curvature < 0.0);
                }
            }
        }
    }
}

BOOST_AUTO_TEST_CASE(testPdf) {
    // Check that the p.d.f. is the derivative of the c.d.f.

    double tolerance = 1e-6;
    double eps = 1e-6;
    TDoubleVec degreesFreedom{2.0, 10.0, 40.0};
    TDoubleVec locations{1.0, 2.0, 3.0};
    TDoubleVec squareScales{0.5, 1, 1.5};

    for (std::size_t test = 0; test < 3; ++test) {
        CLogTDistribution logt(degreesFreedom[test], locations[test],
                               std::sqrt(squareScales[test]));

        for (unsigned int p = 1; p < 100; ++p) {
            double q = static_cast<double>(p) / 100.0;
            double x = quantile(logt, q);

            double pdf = maths::common::pdf(logt, x);
            double dcdfdx = (cdf(logt, x + eps) - cdf(logt, x - eps)) / 2.0 / eps;

            LOG_DEBUG(<< "percentile = " << p << "%"
                      << ", pdf = " << pdf << ", dcdfdx = " << dcdfdx);

            BOOST_REQUIRE_CLOSE_ABSOLUTE(pdf, dcdfdx, tolerance);
        }
    }
}

BOOST_AUTO_TEST_CASE(testCdf) {
    // The idea here is that the distribution should describe data
    // generated by exp(X / s + m)) where X is student's t.

    std::size_t nSamples = 100000;
    TDoubleVec degreesFreedom{2.0, 10.0, 40.0};
    TDoubleVec locations{1.0, 2.0, 3.0};
    TDoubleVec squareScales{0.5, 1, 1.5};

    CRandomNumbers rng;

    for (std::size_t test = 0; test < 3; ++test) {
        TDoubleVec samples;
        rng.generateStudentsSamples(degreesFreedom[test], nSamples, samples);

        for (auto& sample : samples) {
            sample = std::exp(sample * std::sqrt(squareScales[test]) + locations[test]);
        }

        // Check the data percentiles.
        CLogTDistribution logt(degreesFreedom[test], locations[test],
                               std::sqrt(squareScales[test]));

        std::sort(samples.begin(), samples.end());
        for (unsigned int p = 1; p < 100; ++p) {
            double x = samples[nSamples * p / 100];
            double actualCdf = cdf(logt, x);
            double expectedCdf = static_cast<double>(p) / 100;

            LOG_DEBUG(<< "percentile = " << p << "%"
                      << ", actual cdf = " << actualCdf
                      << ", expected cdf = " << expectedCdf);

            // No more than a 10% error in the sample percentile.
            BOOST_REQUIRE_CLOSE_ABSOLUTE(expectedCdf, actualCdf, 0.1 * expectedCdf);
        }
    }
}

BOOST_AUTO_TEST_CASE(testQuantile) {
    // Check that the quantile is the inverse of the c.d.f.

    TDoubleVec degreesFreedom{2.0, 10.0, 40.0};
    TDoubleVec locations{1.0, 2.0, 3.0};
    TDoubleVec squareScales{0.5, 1, 1.5};

    for (std::size_t test = 0; test < 3; ++test) {
        CLogTDistribution logt(degreesFreedom[test], locations[test],
                               std::sqrt(squareScales[test]));

        for (unsigned int p = 1; p < 100; ++p) {
            double q = static_cast<double>(p) / 100.0;

            // Check that the quantile function is the inverse
            // of the c.d.f.
            BOOST_REQUIRE_CLOSE_ABSOLUTE(q, cdf(logt, quantile(logt, q)), 1e-10);
        }
    }
}

BOOST_AUTO_TEST_SUITE_END()
